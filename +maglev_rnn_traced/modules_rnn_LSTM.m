classdef modules_rnn_LSTM < nnet.layer.Layer & nnet.layer.Formattable & ...
        nnet.layer.AutogeneratedFromPyTorch & nnet.layer.Acceleratable
    %modules_rnn_LSTM Auto-generated custom layer
    % Auto-generated by MATLAB on 08-Jun-2025 22:01:29
    
    properties (Learnable)
        % Networks (type dlnetwork)
        
    end
    
    properties
        % Non-Trainable Parameters
        Constant_59
        Constant_35
        Constant_78
        Constant_32
        Constant_19
        Constant_25
        Constant_29
        Constant_31
        Constant_60
        
        
        
    end
    
    properties (Learnable)
        % Trainable Parameters
        Param_bias_hh_l1
        Param_bias_ih_l1
        Param_weight_hh_l1
        Param_weight_ih_l1
        Param_bias_hh_l0
        Param_bias_ih_l0
        Param_weight_hh_l0
        Param_weight_ih_l0
    end
    
    methods
        function obj = modules_rnn_LSTM(Name, Type, InputNames, OutputNames)
            obj.Name = Name;
            obj.Type = Type;
            obj.NumInputs = 1;
            obj.NumOutputs = 2;
            obj.InputNames = InputNames;
            obj.OutputNames = OutputNames;
        end
        
        function [lstm_out_1, lstm_out_1_rank] = predict(obj,size_x_1)
            
            %Validates that the input has the correct format and permutes its dimensions into the reverse of the original PyTorch format.
            maglev_rnn_traced.ops.validateInput(size_x_1,'');
            [size_x_1, size_x_1_format] = maglev_rnn_traced.ops.permuteInputToReversePyTorch(size_x_1, '');
            
            if ~contains(size_x_1_format,'U')
                [size_x_1] = struct('value', size_x_1, 'rank', numel(size_x_1_format));
            end
            
            [lstm_out_1] = tracedPyTorchFunction(obj,size_x_1,false,"predict");
            
            [lstm_out_1_rank] = ones([1,lstm_out_1.rank], 'single');
            lstm_out_1_rank = dlarray(lstm_out_1_rank,'UU');
            %Permute U-labelled output to forward PyTorch dimension ordering
            if(any(dims(lstm_out_1.value) == 'U'))
                lstm_out_1 = permute(lstm_out_1.value, fliplr(1:max(2,lstm_out_1.rank)));
            end
            
        end
        
        
        
        function [lstm_out_1, lstm_out_1_rank] = forward(obj,size_x_1)
            
            %Validates that the input has the correct format and permutes its dimensions into the reverse of the original PyTorch format.
            maglev_rnn_traced.ops.validateInput(size_x_1,'');
            [size_x_1, size_x_1_format] = maglev_rnn_traced.ops.permuteInputToReversePyTorch(size_x_1, '');
            
            if ~contains(size_x_1_format,'U')
                [size_x_1] = struct('value', size_x_1, 'rank', numel(size_x_1_format));
            end
            
            [lstm_out_1] = tracedPyTorchFunction(obj,size_x_1,true,"forward");
            
            [lstm_out_1_rank] = ones([1,lstm_out_1.rank], 'single');
            lstm_out_1_rank = dlarray(lstm_out_1_rank,'UU');
            %Permute U-labelled output to forward PyTorch dimension ordering
            if(any(dims(lstm_out_1.value) == 'U'))
                lstm_out_1 = permute(lstm_out_1.value, fliplr(1:max(2,lstm_out_1.rank)));
            end
            
        end
        
        
        
        function [lstm_out_1] = tracedPyTorchFunction(obj,size_x_1,isForward,predict)
            
            [Constant_59] = maglev_rnn_traced.ops.makeStructForConstant(int64(obj.Constant_59), int64(0), "Typed");
            [Constant_35] = maglev_rnn_traced.ops.makeStructForConstant(int64(obj.Constant_35), int64(0), "Typed");
            Constant_78 = obj.Constant_78;
            [Constant_32] = maglev_rnn_traced.ops.makeStructForConstant(double(obj.Constant_32), int64(0), "Typed");
            [Constant_19] = maglev_rnn_traced.ops.makeStructForConstant(int64(obj.Constant_19), int64(0), "Typed");
            [Constant_25] = maglev_rnn_traced.ops.makeStructForConstant(int64(obj.Constant_25), int64(0), "Typed");
            [Constant_29] = maglev_rnn_traced.ops.makeStructForConstant(int64(obj.Constant_29), int64(0), "Typed");
            [Constant_31] = maglev_rnn_traced.ops.makeStructForConstant(int64(obj.Constant_31), int64(0), "Typed");
            [Constant_60] = maglev_rnn_traced.ops.makeStructForConstant(single(obj.Constant_60), int64(0), "Typed");
            GetAttr_biashhl1_1 = obj.Param_bias_hh_l1;
            
            [GetAttr_biashhl1_1] = struct('value', dlarray(GetAttr_biashhl1_1,'UU'), 'rank', 1);
            
            GetAttr_biasihl1_1 = obj.Param_bias_ih_l1;
            
            [GetAttr_biasihl1_1] = struct('value', dlarray(GetAttr_biasihl1_1,'UU'), 'rank', 1);
            
            GetAttr_weighthhl1_1 = obj.Param_weight_hh_l1;
            
            [GetAttr_weighthhl1_1] = struct('value', dlarray(GetAttr_weighthhl1_1,'UU'), 'rank', 2);
            
            GetAttr_weightihl1_1 = obj.Param_weight_ih_l1;
            
            [GetAttr_weightihl1_1] = struct('value', dlarray(GetAttr_weightihl1_1,'UU'), 'rank', 2);
            
            GetAttr_biashhl0_1 = obj.Param_bias_hh_l0;
            
            [GetAttr_biashhl0_1] = struct('value', dlarray(GetAttr_biashhl0_1,'UU'), 'rank', 1);
            
            GetAttr_biasihl0_1 = obj.Param_bias_ih_l0;
            
            [GetAttr_biasihl0_1] = struct('value', dlarray(GetAttr_biasihl0_1,'UU'), 'rank', 1);
            
            GetAttr_weighthhl0_1 = obj.Param_weight_hh_l0;
            
            [GetAttr_weighthhl0_1] = struct('value', dlarray(GetAttr_weighthhl0_1,'UU'), 'rank', 2);
            
            GetAttr_weightihl0_1 = obj.Param_weight_ih_l0;
            
            [GetAttr_weightihl0_1] = struct('value', dlarray(GetAttr_weightihl0_1,'UU'), 'rank', 2);
            
            [size_20] = maglev_rnn_traced.ops.pySize(size_x_1, Constant_19);
            [NumToTensor_maxbatchsize_1] = maglev_rnn_traced.ops.makeStructForConstant(single(size_20.value), int64([size_20.rank]), "Tensor");
            [Int_24] = maglev_rnn_traced.ops.makeStructForConstant(NumToTensor_maxbatchsize_1.value, int64([NumToTensor_maxbatchsize_1.rank]), "Integer");
            [Int_28] = maglev_rnn_traced.ops.makeStructForConstant(NumToTensor_maxbatchsize_1.value, int64([NumToTensor_maxbatchsize_1.rank]), "Integer");
            [ListConstruct_30] = maglev_rnn_traced.ops.pyListConstruct(Constant_25, Int_28, Constant_29);
            [zeros_hx_1] = maglev_rnn_traced.ops.pyZeros(ListConstruct_30);
            [ListConstruct_38] = maglev_rnn_traced.ops.pyListConstruct(Constant_25, Int_24, Constant_29);
            [zeros_hx0_1] = maglev_rnn_traced.ops.pyZeros(ListConstruct_38);
            [ListConstruct_46] = maglev_rnn_traced.ops.pyListConstruct(zeros_hx_1, zeros_hx0_1);
            [ListConstruct_55] = maglev_rnn_traced.ops.pyListConstruct(GetAttr_weightihl0_1, GetAttr_weighthhl0_1, GetAttr_biasihl0_1, GetAttr_biashhl0_1, GetAttr_weightihl1_1, GetAttr_weighthhl1_1, GetAttr_biasihl1_1, GetAttr_biashhl1_1);
            % Placeholder function for aten::lstm.
            [lstm_out_1, lstm_65, lstm_66] = maglev_rnn_traced.ops.pyAtenLstm(size_x_1, ListConstruct_46, ListConstruct_55, Constant_59, Constant_25, Constant_60, Constant_35, Constant_35, Constant_59);
        end
        
    end
end

